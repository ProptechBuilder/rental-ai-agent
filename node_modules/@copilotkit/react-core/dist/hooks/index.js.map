{"version":3,"sources":["../../src/hooks/index.ts","../../src/hooks/use-copilot-chat.ts","../../src/context/copilot-context.tsx","../../src/hooks/use-chat.ts","../../src/utils/fetch-chat-completion.ts","../../src/components/copilot-provider/copilotkit.tsx","../../src/hooks/use-make-copilot-actionable.ts","../../src/hooks/use-copilot-action.ts","../../src/hooks/use-make-copilot-readable.ts","../../src/hooks/use-make-copilot-document-readable.ts","../../src/hooks/use-copilot-readable.ts"],"sourcesContent":["export { useCopilotChat } from \"./use-copilot-chat\";\nexport type { UseCopilotChatOptions } from \"./use-copilot-chat\";\nexport type { UseCopilotChatReturn } from \"./use-copilot-chat\";\n\nexport { useMakeCopilotActionable } from \"./use-make-copilot-actionable\";\nexport { useCopilotAction } from \"./use-copilot-action\";\nexport { useMakeCopilotReadable } from \"./use-make-copilot-readable\";\nexport { useMakeCopilotDocumentReadable } from \"./use-make-copilot-document-readable\";\nexport { type UseChatHelpers } from \"./use-chat\";\nexport { useCopilotReadable } from \"./use-copilot-readable\";\n","/**\n * A hook for accessing Copilot's chat API.\n *\n * `useCopilotChat` is a React hook that lets you directly interact with the\n * Copilot instance. Use to implement a fully custom UI (headless UI) or to\n * programmatically interact with the Copilot instance managed by the default\n * UI.\n *\n * <RequestExample>\n *   ```jsx useCopilotChat Example\n *   import { useCopilotChat }\n *     from \"@copilotkit/react-core\";\n *\n *   const { appendMessage } = useCopilotChat();\n *   appendMessage({ content: \"Hello, world!\", role: \"user\", id: \"1\" });\n *   ```\n * </RequestExample>\n *\n * useCopilotChat returns an object with the following properties:\n * - `visibleMessages`: An array of messages that are currently visible in the chat.\n * - `appendMessage`: A function to append a message to the chat.\n * - `setMessages`: A function to set the messages in the chat.\n * - `deleteMessage`: A function to delete a message from the chat.\n * - `reloadMessages`: A function to reload the messages from the API.\n * - `stopGeneration`: A function to stop the generation of the next message.\n * - `isLoading`: A boolean indicating if the chat is loading.\n *\n */\nimport { useMemo, useContext, useRef, useEffect, useCallback } from \"react\";\nimport { CopilotContext } from \"../context/copilot-context\";\nimport { Message, ToolDefinition } from \"@copilotkit/shared\";\nimport { SystemMessageFunction } from \"../types\";\nimport { useChat } from \"./use-chat\";\nimport { defaultCopilotContextCategories } from \"../components\";\n\nexport interface UseCopilotChatOptions {\n  /**\n   * A unique identifier for the chat. If not provided, a random one will be\n   * generated. When provided, the `useChat` hook with the same `id` will\n   * have shared states across components.\n   */\n  id?: string;\n\n  /**\n   * HTTP headers to be sent with the API request.\n   */\n  headers?: Record<string, string> | Headers;\n\n  /**\n   * Extra body object to be sent with the API request.\n   * @example\n   * Send a `sessionId` to the API along with the messages.\n   * ```js\n   * useChat({\n   *   body: {\n   *     sessionId: '123',\n   *   }\n   * })\n   * ```\n   */\n  body?: object;\n  /**\n   * System messages of the chat. Defaults to an empty array.\n   */\n  initialMessages?: Message[];\n\n  /**\n   * A function to generate the system message. Defaults to `defaultSystemMessage`.\n   */\n  makeSystemMessage?: SystemMessageFunction;\n}\n\nexport interface UseCopilotChatReturn {\n  visibleMessages: Message[];\n  appendMessage: (message: Message) => Promise<void>;\n  setMessages: (messages: Message[]) => void;\n  deleteMessage: (messageId: string) => void;\n  reloadMessages: () => Promise<void>;\n  stopGeneration: () => void;\n  isLoading: boolean;\n}\n\nexport function useCopilotChat({\n  makeSystemMessage,\n  ...options\n}: UseCopilotChatOptions = {}): UseCopilotChatReturn {\n  const {\n    getContextString,\n    getChatCompletionFunctionDescriptions,\n    getFunctionCallHandler,\n    copilotApiConfig,\n    messages,\n    setMessages,\n    isLoading,\n    setIsLoading,\n    chatInstructions,\n  } = useContext(CopilotContext);\n\n  // We need to ensure that makeSystemMessageCallback always uses the latest\n  // useCopilotReadable data.\n  const latestGetContextString = useUpdatedRef(getContextString);\n  const deleteMessage = useCallback(\n    (messageId: string) => {\n      setMessages((prev) => prev.filter((message) => message.id !== messageId));\n    },\n    [setMessages],\n  );\n\n  const makeSystemMessageCallback = useCallback(() => {\n    const systemMessageMaker = makeSystemMessage || defaultSystemMessage;\n    // this always gets the latest context string\n    const contextString = latestGetContextString.current([], defaultCopilotContextCategories); // TODO: make the context categories configurable\n\n    return {\n      id: \"system\",\n      content: systemMessageMaker(contextString, chatInstructions),\n      role: \"system\",\n    } as Message;\n  }, [getContextString, makeSystemMessage, chatInstructions]);\n\n  const functionDescriptions: ToolDefinition[] = useMemo(() => {\n    return getChatCompletionFunctionDescriptions();\n  }, [getChatCompletionFunctionDescriptions]);\n\n  const { append, reload, stop } = useChat({\n    ...options,\n    copilotConfig: copilotApiConfig,\n    id: options.id,\n    initialMessages: options.initialMessages || [],\n    tools: functionDescriptions,\n    onFunctionCall: getFunctionCallHandler(),\n    headers: { ...options.headers },\n    body: {\n      ...options.body,\n    },\n    messages,\n    setMessages,\n    makeSystemMessageCallback,\n    isLoading,\n    setIsLoading,\n  });\n\n  const visibleMessages = messages.filter(\n    (message) =>\n      message.role === \"user\" || message.role === \"assistant\" || message.role === \"function\",\n  );\n\n  return {\n    visibleMessages,\n    appendMessage: append,\n    setMessages,\n    reloadMessages: reload,\n    stopGeneration: stop,\n    deleteMessage,\n    isLoading,\n  };\n}\n\n// store `value` in a ref and update\n// it whenever it changes.\nfunction useUpdatedRef<T>(value: T) {\n  const ref = useRef(value);\n\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n\n  return ref;\n}\n\nexport function defaultSystemMessage(\n  contextString: string,\n  additionalInstructions?: string,\n): string {\n  return (\n    `\nPlease act as an efficient, competent, conscientious, and industrious professional assistant.\n\nHelp the user achieve their goals, and you do so in a way that is as efficient as possible, without unnecessary fluff, but also without sacrificing professionalism.\nAlways be polite and respectful, and prefer brevity over verbosity.\n\nThe user has provided you with the following context:\n\\`\\`\\`\n${contextString}\n\\`\\`\\`\n\nThey have also provided you with functions you can call to initiate actions on their behalf, or functions you can call to receive more information.\n\nPlease assist them as best you can.\n\nYou can ask them for clarifying questions if needed, but don't be annoying about it. If you can reasonably 'fill in the blanks' yourself, do so.\n\nIf you would like to call a function, call it without saying anything else.\n` + (additionalInstructions ? `\\n\\n${additionalInstructions}` : \"\")\n  );\n}\n","import {\n  CopilotCloudConfig,\n  FunctionCallHandler,\n  Message,\n  ToolDefinition,\n} from \"@copilotkit/shared\";\nimport { ActionRenderProps, FrontendAction } from \"../types/frontend-action\";\nimport React from \"react\";\nimport { TreeNodeId } from \"../hooks/use-tree\";\nimport { DocumentPointer } from \"../types\";\nimport { CopilotChatSuggestionConfiguration } from \"../types/chat-suggestion-configuration\";\n\n/**\n * Interface for the configuration of the Copilot API.\n */\nexport interface CopilotApiConfig {\n  /**\n   * The public API key for Copilot Cloud.\n   */\n  publicApiKey?: string;\n\n  /**\n   * The configuration for Copilot Cloud.\n   */\n  cloud?: CopilotCloudConfig;\n\n  /**\n   * The endpoint for the chat API.\n   */\n  chatApiEndpoint: string;\n\n  /**\n   * The endpoint for the Copilot transcribe audio service.\n   */\n  transcribeAudioUrl?: string;\n\n  /**\n   * The endpoint for the Copilot text to speech service.\n   */\n  textToSpeechUrl?: string;\n\n  /**\n   * The endpoint for the chat API v2.\n   */\n  chatApiEndpointV2: string;\n\n  /**\n   * additional headers to be sent with the request\n   * @default {}\n   * @example\n   * ```\n   * {\n   *   'Authorization': 'Bearer your_token_here'\n   * }\n   * ```\n   */\n  headers: Record<string, string>;\n\n  /**\n   * Additional body params to be sent with the request\n   * @default {}\n   * @example\n   * ```\n   * {\n   *   'message': 'Hello, world!'\n   * }\n   * ```\n   */\n  body: Record<string, any>;\n\n  /**\n   * Backend only props that will be combined to body params to be sent with the request\n   * @default {}\n   * @example\n   * ```\n   * {\n   *   'user_id': 'user_id'\n   * }\n   * ```\n   */\n  backendOnlyProps?: Record<string, any>;\n\n  /**\n   * Indicates whether the user agent should send or receive cookies from the other domain\n   * in the case of cross-origin requests.\n   */\n  credentials?: RequestCredentials;\n}\n\nexport type InChatRenderFunction = (props: ActionRenderProps<any>) => string | JSX.Element;\n\nexport interface CopilotContextParams {\n  // function-calling\n  entryPoints: Record<string, FrontendAction<any>>;\n  setEntryPoint: (id: string, entryPoint: FrontendAction<any>) => void;\n  removeEntryPoint: (id: string) => void;\n  chatComponentsCache: React.RefObject<Record<string, InChatRenderFunction | string>>;\n  getChatCompletionFunctionDescriptions: (\n    customEntryPoints?: Record<string, FrontendAction<any>>,\n  ) => ToolDefinition[];\n  getFunctionCallHandler: (\n    customEntryPoints?: Record<string, FrontendAction<any>>,\n  ) => FunctionCallHandler;\n\n  // text context\n  addContext: (context: string, parentId?: string, categories?: string[]) => TreeNodeId;\n  removeContext: (id: TreeNodeId) => void;\n  getContextString: (documents: DocumentPointer[], categories: string[]) => string;\n\n  // document context\n  addDocumentContext: (documentPointer: DocumentPointer, categories?: string[]) => TreeNodeId;\n  removeDocumentContext: (documentId: string) => void;\n  getDocumentsContext: (categories: string[]) => DocumentPointer[];\n\n  // chat\n  messages: Message[];\n  setMessages: React.Dispatch<React.SetStateAction<Message[]>>;\n\n  isLoading: boolean;\n  setIsLoading: React.Dispatch<React.SetStateAction<boolean>>;\n\n  chatSuggestionConfiguration: { [key: string]: CopilotChatSuggestionConfiguration };\n  addChatSuggestionConfiguration: (\n    id: string,\n    suggestion: CopilotChatSuggestionConfiguration,\n  ) => void;\n  removeChatSuggestionConfiguration: (id: string) => void;\n\n  chatInstructions: string;\n  setChatInstructions: React.Dispatch<React.SetStateAction<string>>;\n\n  // api endpoints\n  copilotApiConfig: CopilotApiConfig;\n}\n\nconst emptyCopilotContext: CopilotContextParams = {\n  entryPoints: {},\n  setEntryPoint: () => {},\n  removeEntryPoint: () => {},\n\n  chatComponentsCache: { current: {} },\n  getContextString: (documents: DocumentPointer[], categories: string[]) =>\n    returnAndThrowInDebug(\"\"),\n  addContext: () => \"\",\n  removeContext: () => {},\n\n  getChatCompletionFunctionDescriptions: () => returnAndThrowInDebug([]),\n  getFunctionCallHandler: () => returnAndThrowInDebug(async () => {}),\n\n  messages: [],\n  setMessages: () => returnAndThrowInDebug([]),\n\n  isLoading: false,\n  setIsLoading: () => returnAndThrowInDebug(false),\n\n  chatInstructions: \"\",\n  setChatInstructions: () => returnAndThrowInDebug(\"\"),\n\n  getDocumentsContext: (categories: string[]) => returnAndThrowInDebug([]),\n  addDocumentContext: () => returnAndThrowInDebug(\"\"),\n  removeDocumentContext: () => {},\n\n  copilotApiConfig: new (class implements CopilotApiConfig {\n    get chatApiEndpoint(): string {\n      throw new Error(\"Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!\");\n    }\n    get chatApiEndpointV2(): string {\n      throw new Error(\"Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!\");\n    }\n    get headers(): Record<string, string> {\n      return {};\n    }\n    get body(): Record<string, any> {\n      return {};\n    }\n  })(),\n\n  chatSuggestionConfiguration: {},\n  addChatSuggestionConfiguration: () => {},\n  removeChatSuggestionConfiguration: () => {},\n};\n\nexport const CopilotContext = React.createContext<CopilotContextParams>(emptyCopilotContext);\n\nexport function useCopilotContext(): CopilotContextParams {\n  return React.useContext(CopilotContext);\n}\n\nfunction returnAndThrowInDebug<T>(value: T): T {\n  throw new Error(\"Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!\");\n  return value;\n}\n","import { useRef, useState, useContext, useEffect } from \"react\";\nimport { CopilotContext } from \"../context/copilot-context\";\nimport {\n  Message,\n  ToolDefinition,\n  FunctionCallHandler,\n  encodeResult,\n  FunctionCall,\n  COPILOT_CLOUD_PUBLIC_API_KEY_HEADER,\n} from \"@copilotkit/shared\";\n\nimport { nanoid } from \"nanoid\";\nimport { fetchAndDecodeChatCompletion } from \"../utils/fetch-chat-completion\";\nimport { CopilotApiConfig } from \"../context\";\nimport untruncateJson from \"untruncate-json\";\n\nexport type UseChatOptions = {\n  /**\n   * The API endpoint that accepts a `{ messages: Message[] }` object and returns\n   * a stream of tokens of the AI chat response. Defaults to `/api/chat`.\n   */\n  api?: string;\n  /**\n   * A unique identifier for the chat. If not provided, a random one will be\n   * generated. When provided, the `useChat` hook with the same `id` will\n   * have shared states across components.\n   */\n  id?: string;\n  /**\n   * System messages of the chat. Defaults to an empty array.\n   */\n  initialMessages?: Message[];\n  /**\n   * Callback function to be called when a function call is received.\n   * If the function returns a `ChatRequest` object, the request will be sent\n   * automatically to the API and will be used to update the chat.\n   */\n  onFunctionCall?: FunctionCallHandler;\n  /**\n   * HTTP headers to be sent with the API request.\n   */\n  headers?: Record<string, string> | Headers;\n  /**\n   * Extra body object to be sent with the API request.\n   * @example\n   * Send a `sessionId` to the API along with the messages.\n   * ```js\n   * useChat({\n   *   body: {\n   *     sessionId: '123',\n   *   }\n   * })\n   * ```\n   */\n  body?: object;\n  /**\n   * Function definitions to be sent to the API.\n   */\n  tools?: ToolDefinition[];\n};\n\nexport type UseChatHelpers = {\n  /**\n   * Append a user message to the chat list. This triggers the API call to fetch\n   * the assistant's response.\n   * @param message The message to append\n   */\n  append: (message: Message) => Promise<void>;\n  /**\n   * Reload the last AI chat response for the given chat history. If the last\n   * message isn't from the assistant, it will request the API to generate a\n   * new response.\n   */\n  reload: () => Promise<void>;\n  /**\n   * Abort the current request immediately, keep the generated tokens if any.\n   */\n  stop: () => void;\n};\n\nexport type UseChatOptionsWithCopilotConfig = UseChatOptions & {\n  copilotConfig: CopilotApiConfig;\n  /**\n   * The current list of messages in the chat.\n   */\n  messages: Message[];\n  /**\n   * The setState-powered method to update the chat messages.\n   */\n  setMessages: React.Dispatch<React.SetStateAction<Message[]>>;\n\n  /**\n   * A callback to get the latest system message.\n   */\n  makeSystemMessageCallback: () => Message;\n\n  /**\n   * Whether the API request is in progress\n   */\n  isLoading: boolean;\n\n  /**\n   * setState-powered method to update the isChatLoading value\n   */\n  setIsLoading: React.Dispatch<React.SetStateAction<boolean>>;\n};\n\nexport function useChat(options: UseChatOptionsWithCopilotConfig): UseChatHelpers {\n  const { messages, setMessages, makeSystemMessageCallback } = options;\n  const abortControllerRef = useRef<AbortController>();\n  const threadIdRef = useRef<string | null>(null);\n  const runIdRef = useRef<string | null>(null);\n  const publicApiKey = options.copilotConfig.publicApiKey;\n  const headers = {\n    ...(options.headers || {}),\n    ...(publicApiKey ? { [COPILOT_CLOUD_PUBLIC_API_KEY_HEADER]: publicApiKey } : {}),\n  };\n\n  const runChatCompletion = async (messages: Message[]): Promise<Message[]> => {\n    options.setIsLoading(true);\n\n    const newMessages: Message[] = [\n      {\n        id: nanoid(),\n        createdAt: new Date(),\n        content: \"\",\n        role: \"assistant\",\n      },\n    ];\n    const abortController = new AbortController();\n    abortControllerRef.current = abortController;\n\n    setMessages([...messages, ...newMessages]);\n    // add threadId and runId to the body if it exists\n    const copilotConfigBody = options.copilotConfig.body || {};\n    if (threadIdRef.current) {\n      copilotConfigBody.threadId = threadIdRef.current;\n    }\n    if (runIdRef.current) {\n      copilotConfigBody.runId = runIdRef.current;\n    }\n\n    const systemMessage = makeSystemMessageCallback();\n\n    const messagesWithContext = [systemMessage, ...(options.initialMessages || []), ...messages];\n    const response = await fetchAndDecodeChatCompletion({\n      copilotConfig: { ...options.copilotConfig, body: copilotConfigBody },\n      messages: messagesWithContext,\n      tools: options.tools,\n      headers: headers,\n      signal: abortController.signal,\n    });\n\n    if (response.headers.get(\"threadid\")) {\n      threadIdRef.current = response.headers.get(\"threadid\");\n    }\n\n    if (response.headers.get(\"runid\")) {\n      runIdRef.current = response.headers.get(\"runid\");\n    }\n\n    if (!response.events) {\n      setMessages([\n        ...messages,\n        {\n          id: nanoid(),\n          createdAt: new Date(),\n          content: response.statusText,\n          role: \"assistant\",\n        },\n      ]);\n      options.setIsLoading(false);\n      throw new Error(\"Failed to fetch chat completion\");\n    }\n\n    const reader = response.events.getReader();\n\n    // Whether to feed back the new messages to GPT\n    let feedback = false;\n\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n\n        if (done) {\n          break;\n        }\n\n        let currentMessage = Object.assign({}, newMessages[newMessages.length - 1]);\n\n        if (value.type === \"content\") {\n          if (currentMessage.function_call || currentMessage.role === \"function\") {\n            // Create a new message if the previous one is a function call or result\n            currentMessage = {\n              id: nanoid(),\n              createdAt: new Date(),\n              content: \"\",\n              role: \"assistant\",\n            };\n            newMessages.push(currentMessage);\n          }\n          currentMessage.content += value.content;\n          newMessages[newMessages.length - 1] = currentMessage;\n          setMessages([...messages, ...newMessages]);\n        } else if (value.type === \"result\") {\n          // When we get a result message, it is already complete\n          currentMessage = {\n            id: nanoid(),\n            role: \"function\",\n            content: value.content,\n            name: value.name,\n          };\n          newMessages.push(currentMessage);\n          setMessages([...messages, ...newMessages]);\n\n          // After receiving a result, feed back the new messages to GPT\n          feedback = true;\n        } else if (value.type === \"function\" || value.type === \"partial\") {\n          // Create a new message if the previous one is not empty\n          if (\n            currentMessage.content != \"\" ||\n            currentMessage.function_call ||\n            currentMessage.role == \"function\"\n          ) {\n            currentMessage = {\n              id: nanoid(),\n              createdAt: new Date(),\n              content: \"\",\n              role: \"assistant\",\n            };\n            newMessages.push(currentMessage);\n          }\n          if (value.type === \"function\") {\n            currentMessage.function_call = {\n              name: value.name,\n              arguments: JSON.stringify(value.arguments),\n              scope: value.scope,\n            };\n          } else if (value.type === \"partial\") {\n            let partialArguments: any = {};\n            try {\n              partialArguments = JSON.parse(untruncateJson(value.arguments));\n            } catch (e) {}\n\n            currentMessage.partialFunctionCall = {\n              name: value.name,\n              arguments: partialArguments,\n            };\n          }\n\n          newMessages[newMessages.length - 1] = currentMessage;\n          setMessages([...messages, ...newMessages]);\n\n          if (value.type === \"function\") {\n            // Execute the function call\n            try {\n              if (options.onFunctionCall && value.scope === \"client\") {\n                const result = await options.onFunctionCall(\n                  messages,\n                  currentMessage.function_call as FunctionCall,\n                );\n\n                currentMessage = {\n                  id: nanoid(),\n                  role: \"function\",\n                  content: encodeResult(result),\n                  name: (currentMessage.function_call! as FunctionCall).name!,\n                };\n                newMessages.push(currentMessage);\n                setMessages([...messages, ...newMessages]);\n\n                // After a function call, feed back the new messages to GPT\n                feedback = true;\n              }\n            } catch (error) {\n              console.error(\"Failed to execute function call\", error);\n              // TODO: Handle error\n              // this should go to the message itself\n            }\n          }\n        }\n      }\n\n      // If we want feedback, run the completion again and return the results\n      if (feedback) {\n        // wait for next tick to make sure all the react state updates\n        // TODO: This is a hack, is there a more robust way to do this?\n        // - tried using react-dom's flushSync, but it did not work\n        await new Promise((resolve) => setTimeout(resolve, 10));\n\n        return await runChatCompletion([...messages, ...newMessages]);\n      }\n      // otherwise, return the new messages\n      else {\n        return newMessages.slice();\n      }\n    } finally {\n      options.setIsLoading(false);\n    }\n  };\n\n  const runChatCompletionAndHandleFunctionCall = async (messages: Message[]): Promise<void> => {\n    await runChatCompletion(messages);\n  };\n\n  const append = async (message: Message): Promise<void> => {\n    if (options.isLoading) {\n      return;\n    }\n    const newMessages = [...messages, message];\n    setMessages(newMessages);\n    return runChatCompletionAndHandleFunctionCall(newMessages);\n  };\n\n  const reload = async (): Promise<void> => {\n    if (options.isLoading || messages.length === 0) {\n      return;\n    }\n    let newMessages = [...messages];\n    const lastMessage = messages[messages.length - 1];\n\n    if (lastMessage.role === \"assistant\") {\n      newMessages = newMessages.slice(0, -1);\n    }\n    setMessages(newMessages);\n\n    return runChatCompletionAndHandleFunctionCall(newMessages);\n  };\n\n  const stop = (): void => {\n    abortControllerRef.current?.abort();\n  };\n\n  return {\n    append,\n    reload,\n    stop,\n  };\n}\n","import {\n  Message,\n  ToolDefinition,\n  ChatCompletionEvent,\n  decodeChatCompletion,\n  parseChatCompletion,\n  decodeChatCompletionAsText,\n  EXCLUDE_FROM_FORWARD_PROPS_KEYS,\n} from \"@copilotkit/shared\";\nimport { CopilotApiConfig } from \"../context\";\n\nexport interface FetchChatCompletionParams {\n  copilotConfig: CopilotApiConfig;\n  model?: string;\n  messages: Message[];\n  tools?: ToolDefinition[];\n  temperature?: number;\n  maxTokens?: number;\n  headers?: Record<string, string> | Headers;\n  body?: object;\n  signal?: AbortSignal;\n  toolChoice?: string | { type: \"function\"; function: { name: string } };\n}\n\nexport async function fetchChatCompletion({\n  copilotConfig,\n  model,\n  messages,\n  tools,\n  temperature,\n  headers,\n  body,\n  signal,\n  toolChoice,\n}: FetchChatCompletionParams): Promise<Response> {\n  temperature ||= 0.5;\n  tools ||= [];\n\n  // clean up any extra properties from messages\n  const cleanedMessages = messages.map((message) => {\n    const { content, role, name, function_call } = message;\n    return { content, role, name, function_call };\n  });\n\n  toolChoice ||= \"auto\";\n\n  const response = await fetch(copilotConfig.chatApiEndpoint, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...copilotConfig.headers,\n      ...(headers ? { ...headers } : {}),\n    },\n    body: JSON.stringify({\n      model,\n      messages: cleanedMessages,\n      stream: true,\n      ...(tools.length ? { tools } : {}),\n      ...(temperature ? { temperature } : {}),\n      ...(tools.length != 0 ? { tool_choice: toolChoice } : {}),\n      ...copilotConfig.body,\n      ...copilotConfig.backendOnlyProps,\n      ...excludeBackendOnlyProps(copilotConfig),\n      ...(body ? { ...body } : {}),\n      ...(copilotConfig.cloud ? { cloud: copilotConfig.cloud } : {}),\n    }),\n    signal,\n    credentials: copilotConfig.credentials,\n  });\n\n  return response;\n}\n\nfunction excludeBackendOnlyProps(copilotConfig: any) {\n  const backendOnlyProps = copilotConfig.backendOnlyProps ?? {};\n  if (Object.keys(backendOnlyProps).length > 0) {\n    return {\n      [EXCLUDE_FROM_FORWARD_PROPS_KEYS]: Object.keys(backendOnlyProps),\n    };\n  } else {\n    return {};\n  }\n}\n\nexport interface DecodedChatCompletionResponse extends Response {\n  events: ReadableStream<ChatCompletionEvent> | null;\n}\n\nexport async function fetchAndDecodeChatCompletion(\n  params: FetchChatCompletionParams,\n): Promise<DecodedChatCompletionResponse> {\n  const response = await fetchChatCompletion(params);\n  if (!response.ok || !response.body) {\n    (response as any).events = null;\n  } else {\n    const events = await decodeChatCompletion(parseChatCompletion(response.body));\n    (response as any).events = events;\n  }\n  return response as any;\n}\n\nexport interface DecodedChatCompletionResponseAsText extends Response {\n  events: ReadableStream<string> | null;\n}\n\nexport async function fetchAndDecodeChatCompletionAsText(\n  params: FetchChatCompletionParams,\n): Promise<DecodedChatCompletionResponseAsText> {\n  const response = await fetchChatCompletion(params);\n  if (!response.ok || !response.body) {\n    (response as any).events = null;\n  } else {\n    const events = await decodeChatCompletionAsText(\n      decodeChatCompletion(parseChatCompletion(response.body)),\n    );\n    (response as any).events = events;\n  }\n\n  return response as any;\n}\n","/**\n * Provides the Copilot context to its children.\n * \n * <img\n *   referrerPolicy=\"no-referrer-when-downgrade\"\n *   src=\"https://static.scarf.sh/a.png?x-pxid=a9b290bb-38f9-4518-ac3b-8f54fdbf43be\"\n * />\n * \n * This component provides the Copilot context to its children.\n * It can be configured either with a chat API endpoint or a `CopilotApiConfig`.\n * \n * <Note>\n *   The backend can use OpenAI, or you can bring your own LLM. For examples of the\n *   backend api implementation, see `examples/next-openai` or the [runtime\n *   docs](https://docs.copilotkit.ai/getting-started/quickstart-runtime).\n * </Note>\n * \n * <RequestExample>\n *   ```jsx CopilotKit Example\n *   import { CopilotKit } from \"@copilotkit/react-core\";\n * \n *   <CopilotKit \n *     runtimeUrl=\"https://your.copilotkit.api\">\n *     <YourApp/>\n *   </CopilotKit>\n *   ```\n * </RequestExample>\n * \n * ## Example usage\n * \n * ```jsx\n * <CopilotKit publicApiKey=\"the api key or self host (see below)\">\n *   <App />\n * </CopilotKit>\n```\n */\nimport { Ref, useCallback, useRef, useState } from \"react\";\nimport {\n  CopilotContext,\n  CopilotApiConfig,\n  InChatRenderFunction,\n} from \"../../context/copilot-context\";\nimport useTree from \"../../hooks/use-tree\";\nimport { CopilotChatSuggestionConfiguration, DocumentPointer } from \"../../types\";\n\nimport {\n  COPILOT_CLOUD_CHAT_URL,\n  CopilotCloudConfig,\n  FunctionCallHandler,\n  Message,\n  actionToChatCompletionFunction,\n} from \"@copilotkit/shared\";\n\nimport { FrontendAction } from \"../../types/frontend-action\";\nimport useFlatCategoryStore from \"../../hooks/use-flat-category-store\";\nimport { CopilotKitProps } from \"./copilotkit-props\";\nimport { ToolDefinition } from \"@copilotkit/shared\";\n\nexport function CopilotKit({ children, ...props }: CopilotKitProps) {\n  // Compute all the functions and properties that we need to pass\n  // to the CopilotContext.\n\n  if (!props.runtimeUrl && !props.url && !props.publicApiKey) {\n    throw new Error(\"Please provide either a url or a publicApiKey to the CopilotKit component.\");\n  }\n\n  const chatApiEndpoint = props.runtimeUrl || props.url || COPILOT_CLOUD_CHAT_URL;\n\n  const [entryPoints, setEntryPoints] = useState<Record<string, FrontendAction<any>>>({});\n  const chatComponentsCache = useRef<Record<string, InChatRenderFunction | string>>({});\n  const { addElement, removeElement, printTree } = useTree();\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [chatInstructions, setChatInstructions] = useState(\"\");\n\n  const {\n    addElement: addDocument,\n    removeElement: removeDocument,\n    allElements: allDocuments,\n  } = useFlatCategoryStore<DocumentPointer>();\n\n  const setEntryPoint = useCallback((id: string, entryPoint: FrontendAction<any>) => {\n    setEntryPoints((prevPoints) => {\n      return {\n        ...prevPoints,\n        [id]: entryPoint,\n      };\n    });\n  }, []);\n\n  const removeEntryPoint = useCallback((id: string) => {\n    setEntryPoints((prevPoints) => {\n      const newPoints = { ...prevPoints };\n      delete newPoints[id];\n      return newPoints;\n    });\n  }, []);\n\n  const getContextString = useCallback(\n    (documents: DocumentPointer[], categories: string[]) => {\n      const documentsString = documents\n        .map((document) => {\n          return `${document.name} (${document.sourceApplication}):\\n${document.getContents()}`;\n        })\n        .join(\"\\n\\n\");\n\n      const nonDocumentStrings = printTree(categories);\n\n      return `${documentsString}\\n\\n${nonDocumentStrings}`;\n    },\n    [printTree],\n  );\n\n  const addContext = useCallback(\n    (\n      context: string,\n      parentId?: string,\n      categories: string[] = defaultCopilotContextCategories,\n    ) => {\n      return addElement(context, categories, parentId);\n    },\n    [addElement],\n  );\n\n  const removeContext = useCallback(\n    (id: string) => {\n      removeElement(id);\n    },\n    [removeElement],\n  );\n\n  const getChatCompletionFunctionDescriptions = useCallback(\n    (customEntryPoints?: Record<string, FrontendAction<any>>) => {\n      return entryPointsToChatCompletionFunctions(Object.values(customEntryPoints || entryPoints));\n    },\n    [entryPoints],\n  );\n\n  const getFunctionCallHandler = useCallback(\n    (customEntryPoints?: Record<string, FrontendAction<any>>) => {\n      return entryPointsToFunctionCallHandler(Object.values(customEntryPoints || entryPoints));\n    },\n    [entryPoints],\n  );\n\n  const getDocumentsContext = useCallback(\n    (categories: string[]) => {\n      return allDocuments(categories);\n    },\n    [allDocuments],\n  );\n\n  const addDocumentContext = useCallback(\n    (documentPointer: DocumentPointer, categories: string[] = defaultCopilotContextCategories) => {\n      return addDocument(documentPointer, categories);\n    },\n    [addDocument],\n  );\n\n  const removeDocumentContext = useCallback(\n    (documentId: string) => {\n      removeDocument(documentId);\n    },\n    [removeDocument],\n  );\n\n  if (!props.publicApiKey) {\n    if (props.cloudRestrictToTopic) {\n      throw new Error(\n        \"To use the cloudRestrictToTopic feature, please sign up at https://copilotkit.ai and provide a publicApiKey.\",\n      );\n    }\n  }\n\n  let cloud: CopilotCloudConfig | undefined = undefined;\n  if (props.publicApiKey) {\n    cloud = {\n      guardrails: {\n        input: {\n          restrictToTopic: {\n            enabled: props.cloudRestrictToTopic ? true : false,\n            validTopics: props.cloudRestrictToTopic?.validTopics || [],\n            invalidTopics: props.cloudRestrictToTopic?.invalidTopics || [],\n          },\n        },\n      },\n    };\n  }\n\n  // get the appropriate CopilotApiConfig from the props\n  const copilotApiConfig: CopilotApiConfig = {\n    publicApiKey: props.publicApiKey,\n    ...(cloud ? { cloud } : {}),\n    chatApiEndpoint: chatApiEndpoint,\n    chatApiEndpointV2: `${props.url}/v2`,\n    headers: props.headers || {},\n    body: {\n      ...props.body,\n      ...props.backendOnlyProps,\n    },\n    transcribeAudioUrl: props.transcribeAudioUrl,\n    textToSpeechUrl: props.textToSpeechUrl,\n    credentials: props.credentials,\n  };\n\n  const [chatSuggestionConfiguration, setChatSuggestionConfiguration] = useState<{\n    [key: string]: CopilotChatSuggestionConfiguration;\n  }>({});\n\n  const addChatSuggestionConfiguration = (\n    id: string,\n    suggestion: CopilotChatSuggestionConfiguration,\n  ) => {\n    setChatSuggestionConfiguration((prev) => ({ ...prev, [id]: suggestion }));\n  };\n\n  const removeChatSuggestionConfiguration = (id: string) => {\n    setChatSuggestionConfiguration((prev) => {\n      const { [id]: _, ...rest } = prev;\n      return rest;\n    });\n  };\n\n  return (\n    <CopilotContext.Provider\n      value={{\n        entryPoints,\n        chatComponentsCache,\n        getChatCompletionFunctionDescriptions,\n        getFunctionCallHandler,\n        setEntryPoint,\n        removeEntryPoint,\n        getContextString,\n        addContext,\n        removeContext,\n        getDocumentsContext,\n        addDocumentContext,\n        removeDocumentContext,\n        copilotApiConfig: copilotApiConfig,\n        messages,\n        setMessages,\n        isLoading,\n        setIsLoading,\n        chatSuggestionConfiguration,\n        addChatSuggestionConfiguration,\n        removeChatSuggestionConfiguration,\n        chatInstructions,\n        setChatInstructions,\n      }}\n    >\n      {children}\n    </CopilotContext.Provider>\n  );\n}\n\nexport const defaultCopilotContextCategories = [\"global\"];\n\nfunction entryPointsToChatCompletionFunctions(actions: FrontendAction<any>[]): ToolDefinition[] {\n  return actions.map(actionToChatCompletionFunction);\n}\n\nfunction entryPointsToFunctionCallHandler(actions: FrontendAction<any>[]): FunctionCallHandler {\n  return async (chatMessages, functionCall) => {\n    let actionsByFunctionName: Record<string, FrontendAction<any>> = {};\n    for (let action of actions) {\n      actionsByFunctionName[action.name] = action;\n    }\n\n    const action = actionsByFunctionName[functionCall.name || \"\"];\n    if (action) {\n      let functionCallArguments: Record<string, any>[] = [];\n      if (functionCall.arguments) {\n        functionCallArguments = JSON.parse(functionCall.arguments);\n      }\n      return await action.handler(functionCallArguments);\n    }\n  };\n}\n","import { useRef, useContext, useEffect, useMemo } from \"react\";\nimport { CopilotContext } from \"../context/copilot-context\";\nimport { AnnotatedFunction } from \"@copilotkit/shared\";\nimport { nanoid } from \"nanoid\";\nimport { annotatedFunctionToAction } from \"@copilotkit/shared\";\n\n/**\n * @deprecated Use the useCopilotAction function instead.\n */\nexport function useMakeCopilotActionable<ActionInput extends any[]>(\n  annotatedFunction: AnnotatedFunction<ActionInput>,\n  dependencies: any[],\n) {\n  const idRef = useRef(nanoid()); // generate a unique id\n  const { setEntryPoint, removeEntryPoint } = useContext(CopilotContext);\n\n  const memoizedAnnotatedFunction: AnnotatedFunction<ActionInput> = useMemo(\n    () => ({\n      name: annotatedFunction.name,\n      description: annotatedFunction.description,\n      argumentAnnotations: annotatedFunction.argumentAnnotations,\n      implementation: annotatedFunction.implementation,\n    }),\n    dependencies,\n  );\n\n  useEffect(() => {\n    const action = annotatedFunctionToAction(memoizedAnnotatedFunction as AnnotatedFunction<any[]>);\n    setEntryPoint(idRef.current, action);\n\n    return () => {\n      removeEntryPoint(idRef.current);\n    };\n  }, [memoizedAnnotatedFunction, setEntryPoint, removeEntryPoint]);\n}\n","import { useRef, useContext, useEffect } from \"react\";\nimport { FrontendAction } from \"../types/frontend-action\";\nimport { CopilotContext } from \"../context/copilot-context\";\nimport { nanoid } from \"nanoid\";\nimport { Parameter } from \"@copilotkit/shared\";\n\n// We implement useCopilotAction dependency handling so that\n// the developer has the option to not provide any dependencies.\n// In this case, we assume they want to update the handler on each rerender.\n// To avoid getting stuck in an infinite loop, we update the handler directly,\n// skipping React state updates.\n// This is ok in this case, because the handler is not part of any UI that\n// needs to be updated.\n// useCallback, useMemo or other memoization techniques are not suitable here,\n// because they will cause a infinite rerender loop.\nexport function useCopilotAction<const T extends Parameter[] | [] = []>(\n  action: FrontendAction<T>,\n  dependencies?: any[],\n): void {\n  const { setEntryPoint, removeEntryPoint, entryPoints, chatComponentsCache } =\n    useContext(CopilotContext);\n  const idRef = useRef<string>(nanoid());\n\n  // If the developer doesn't provide dependencies, we assume they want to\n  // update handler and render function when the action object changes.\n  // This ensures that any captured variables in the handler are up to date.\n  if (dependencies === undefined) {\n    if (entryPoints[idRef.current]) {\n      entryPoints[idRef.current].handler = action.handler as any;\n      if (typeof action.render === \"function\") {\n        if (chatComponentsCache.current !== null) {\n          chatComponentsCache.current[action.name] = action.render;\n        }\n      }\n    }\n  }\n\n  useEffect(() => {\n    setEntryPoint(idRef.current, action as any);\n    if (chatComponentsCache.current !== null && action.render !== undefined) {\n      chatComponentsCache.current[action.name] = action.render;\n    }\n    return () => {\n      // NOTE: For now, we don't remove the chatComponentsCache entry when the action is removed.\n      // This is because we currently don't have access to the messages array in CopilotContext.\n      removeEntryPoint(idRef.current);\n    };\n  }, [\n    setEntryPoint,\n    removeEntryPoint,\n    action.description,\n    action.name,\n    // This should be faster than deep equality checking\n    // In addition, all major JS engines guarantee the order of object keys\n    JSON.stringify(action.parameters),\n    // include render only if it's a string\n    typeof action.render === \"string\" ? action.render : undefined,\n    // dependencies set by the developer\n    ...(dependencies || []),\n  ]);\n}\n\n// Usage Example:\n// useCopilotAction({\n//   name: \"myAction\",\n//   parameters: [\n//     { name: \"arg1\", type: \"string\", enum: [\"option1\", \"option2\", \"option3\"], required: false },\n//     { name: \"arg2\", type: \"number\" },\n//     {\n//       name: \"arg3\",\n//       type: \"object\",\n//       attributes: [\n//         { name: \"nestedArg1\", type: \"boolean\" },\n//         { name: \"xyz\", required: false },\n//       ],\n//     },\n//     { name: \"arg4\", type: \"number[]\" },\n//   ],\n//   handler: ({ arg1, arg2, arg3, arg4 }) => {\n//     const x = arg3.nestedArg1;\n//     const z = arg3.xyz;\n//     console.log(arg1, arg2, arg3);\n//   },\n// });\n\n// useCopilotAction({\n//   name: \"myAction\",\n//   handler: () => {\n//     console.log(\"No parameters provided.\");\n//   },\n// });\n","import { useContext, useEffect, useRef } from \"react\";\nimport { CopilotContext } from \"../context/copilot-context\";\n\n/**\n * @deprecated Use the useCopilotReadable function instead.\n */\nexport function useMakeCopilotReadable(\n  information: string,\n  parentId?: string,\n  categories?: string[],\n): string | undefined {\n  const { addContext, removeContext } = useContext(CopilotContext);\n  const idRef = useRef<string>();\n\n  useEffect(() => {\n    const id = addContext(information, parentId, categories);\n    idRef.current = id;\n\n    return () => {\n      removeContext(id);\n    };\n  }, [information, parentId, addContext, removeContext]);\n\n  return idRef.current;\n}\n","import { useContext, useEffect, useRef } from \"react\";\nimport { CopilotContext } from \"../context/copilot-context\";\nimport { DocumentPointer } from \"../types\";\n\n/**\n * Makes a document readable by Copilot.\n * @param document The document to make readable.\n * @param categories The categories to associate with the document.\n * @param dependencies The dependencies to use for the effect.\n * @returns The id of the document.\n */\nexport function useMakeCopilotDocumentReadable(\n  document: DocumentPointer,\n  categories?: string[],\n  dependencies: any[] = [],\n): string | undefined {\n  const { addDocumentContext, removeDocumentContext } = useContext(CopilotContext);\n  const idRef = useRef<string>();\n\n  useEffect(() => {\n    const id = addDocumentContext(document, categories);\n    idRef.current = id;\n\n    return () => {\n      removeDocumentContext(id);\n    };\n  }, [addDocumentContext, removeDocumentContext, ...dependencies]);\n\n  return idRef.current;\n}\n","/**\n * A hook for providing app-state & other information to the Copilot.\n *\n * <img referrerPolicy=\"no-referrer-when-downgrade\" src=\"https://static.scarf.sh/a.png?x-pxid=a9b290bb-38f9-4518-ac3b-8f54fdbf43be\" />\n *\n * `useCopilotReadable` is a React hook that provides app-state and other information\n * to the Copilot. Optionally, the hook can also handle hierarchical state within your\n * application, passing these parent-child relationships to the Copilot.\n *\n * <RequestExample>\n *   ```jsx useCopilotReadable Example\n *   import { useCopilotReadable }\n *     from \"@copilotkit/react-core\";\n *\n *   const myAppState = ...;\n *   useCopilotReadable({\n *     description: \"The current state of the app\",\n *     value: myAppState\n *   });\n *   ```\n * </RequestExample>\n *\n * In its most basic usage, useCopilotReadable accepts a single string argument\n * representing any piece of app state, making it available for the Copilot to use\n * as context when responding to user input.\n *\n * For example:\n *\n * ```jsx simple state example\n * import { useCopilotReadable }  from \"@copilotkit/react-core\";\n *\n * const userName = \"Rust Cohle\";\n * useCopilotReadable({\n *   description: \"The name of the user\",\n *   value: userName\n * });\n * ```\n *\n * You can also pass in an object representing your app state,\n * for example:\n *\n * ```jsx using state\n * import { useCopilotReadable }  from \"@copilotkit/react-core\";\n *\n * const myAppState = {\n *   userName: \"Rust Cohle\",\n *   userAddress: {\n *     street: \"4500 Old Spanish Trail\",\n *     city: \"New Orleans\",\n *     state: \"LA\",\n *     zip: \"70129\"\n *   }\n * };\n * useCopilotReadable({\n *   description: \"The current state of the app\",\n *   value: myAppState\n * });\n * ```\n *\n * Optionally, you can maintain the hierarchical structure of information by passing\n * `parentId`:\n *\n * ```jsx parentId example\n * import { useCopilotReadable } from \"@copilotkit/react-core\";\n *\n *\n * function Employee(props: EmployeeProps) {\n *   const { employeeName, workProfile, metadata } = props;\n *\n *   // propagate any information copilot\n *   const employeeContextId = useCopilotReadable({\n *     description: \"Employee name\",\n *     value: employeeName\n *   });\n *\n *   // Pass a parentID to maintain a hierarchical structure.\n *   // Especially useful with child React components, list elements, etc.\n *   useCopilotReadable({\n *     description: \"Work profile\",\n *     value: workProfile.description(),\n *     parentId: employeeContextId\n *   });\n *   useCopilotReadable({\n *     description: \"Employee metadata\",\n *     value: metadata.description(),\n *     parentId: employeeContextId\n *   });\n *\n *   return (\n *     // Render as usual...\n *   );\n * }\n * ```\n */\nimport { useContext, useEffect, useRef } from \"react\";\nimport { CopilotContext } from \"../context/copilot-context\";\n\n/**\n * Options for the useCopilotReadable hook.\n */\nexport interface UseCopilotReadableOptions {\n  /**\n   * The description of the information to be added to the Copilot context.\n   */\n  description: string;\n  /**\n   * The value to be added to the Copilot context.\n   */\n  value: any;\n  /**\n   * The ID of the parent context, if any.\n   */\n  parentId?: string;\n  /**\n   * An array of categories to control which context are visible where. Particularly useful\n   * with CopilotTextarea (see `useMakeAutosuggestionFunction`)\n   */\n  categories?: string[];\n\n  /**\n   * A custom conversion function to use to serialize the value to a string. If not provided, the value\n   * will be serialized using `JSON.stringify`.\n   */\n  convert?: (description: string, value: any) => string;\n}\n\nfunction convertToJSON(description: string, value: any): string {\n  return `${description}: ${typeof value === \"string\" ? value : JSON.stringify(value)}`;\n}\n\n/**\n * Adds the given information to the Copilot context to make it readable by Copilot.\n */\nexport function useCopilotReadable(\n  { description, value, parentId, categories, convert }: UseCopilotReadableOptions,\n  dependencies?: any[],\n): string | undefined {\n  const { addContext, removeContext } = useContext(CopilotContext);\n  const idRef = useRef<string>();\n  convert = convert || convertToJSON;\n\n  const information = convert(description, value);\n\n  useEffect(() => {\n    const id = addContext(information, parentId, categories);\n    idRef.current = id;\n\n    return () => {\n      removeContext(id);\n    };\n  }, [information, parentId, addContext, removeContext, ...(dependencies || [])]);\n\n  return idRef.current;\n}\n"],"mappings":"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","names":["import_react","React","import_react","import_shared","messages","untruncateJson","import_react","import_shared","import_react","import_nanoid","import_shared","import_react","import_nanoid","import_react","import_react","import_react"]}